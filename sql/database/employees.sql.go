// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: employees.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees
(
    user_id,
    job_title,
    country,
    salary,
    created_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, job_title, country, salary, created_at
`

type CreateEmployeeParams struct {
	UserID    int64            `json:"user_id"`
	JobTitle  string           `json:"job_title"`
	Country   string           `json:"country"`
	Salary    pgtype.Numeric   `json:"salary"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (*Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.UserID,
		arg.JobTitle,
		arg.Country,
		arg.Salary,
		arg.CreatedAt,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobTitle,
		&i.Country,
		&i.Salary,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteEmployeeByUserId = `-- name: DeleteEmployeeByUserId :one
DELETE FROM employees WHERE user_id = $1 RETURNING id, user_id, job_title, country, salary, created_at
`

func (q *Queries) DeleteEmployeeByUserId(ctx context.Context, userID int64) (*Employee, error) {
	row := q.db.QueryRow(ctx, deleteEmployeeByUserId, userID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobTitle,
		&i.Country,
		&i.Salary,
		&i.CreatedAt,
	)
	return &i, err
}

const getAvgSalaryPerJobTitle = `-- name: GetAvgSalaryPerJobTitle :one
SELECT 
    ROUND(AVG(salary), 2)   AS average_salary,
    COUNT(*)                AS employee_count
FROM employees
WHERE job_title = $1
`

type GetAvgSalaryPerJobTitleRow struct {
	AverageSalary pgtype.Numeric `json:"average_salary"`
	EmployeeCount int64          `json:"employee_count"`
}

func (q *Queries) GetAvgSalaryPerJobTitle(ctx context.Context, jobTitle string) (*GetAvgSalaryPerJobTitleRow, error) {
	row := q.db.QueryRow(ctx, getAvgSalaryPerJobTitle, jobTitle)
	var i GetAvgSalaryPerJobTitleRow
	err := row.Scan(&i.AverageSalary, &i.EmployeeCount)
	return &i, err
}

const getEmployeByuserById = `-- name: GetEmployeByuserById :one
SELECT id, user_id, job_title, country, salary, created_at FROM employees WHERE user_id = $1
`

func (q *Queries) GetEmployeByuserById(ctx context.Context, userID int64) (*Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeByuserById, userID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobTitle,
		&i.Country,
		&i.Salary,
		&i.CreatedAt,
	)
	return &i, err
}

const getSalaryMetricsByCountry = `-- name: GetSalaryMetricsByCountry :one
SELECT 
    ROUND(MIN(salary), 2)   AS min_salary,
    ROUND(MAX(salary), 2)   AS max_salary,
    ROUND(AVG(salary), 2)   AS avg_salary,
    COUNT(*)                AS employee_count
FROM employees
WHERE country = $1
`

type GetSalaryMetricsByCountryRow struct {
	MinSalary     pgtype.Numeric `json:"min_salary"`
	MaxSalary     pgtype.Numeric `json:"max_salary"`
	AvgSalary     pgtype.Numeric `json:"avg_salary"`
	EmployeeCount int64          `json:"employee_count"`
}

func (q *Queries) GetSalaryMetricsByCountry(ctx context.Context, country string) (*GetSalaryMetricsByCountryRow, error) {
	row := q.db.QueryRow(ctx, getSalaryMetricsByCountry, country)
	var i GetSalaryMetricsByCountryRow
	err := row.Scan(
		&i.MinSalary,
		&i.MaxSalary,
		&i.AvgSalary,
		&i.EmployeeCount,
	)
	return &i, err
}

const updateEmployeeByUserId = `-- name: UpdateEmployeeByUserId :one
UPDATE employees
SET 
    job_title  = $2,
    country    = $3,
    salary     = $4
WHERE user_id = $1
RETURNING id, user_id, job_title, country, salary, created_at
`

type UpdateEmployeeByUserIdParams struct {
	UserID   int64          `json:"user_id"`
	JobTitle string         `json:"job_title"`
	Country  string         `json:"country"`
	Salary   pgtype.Numeric `json:"salary"`
}

func (q *Queries) UpdateEmployeeByUserId(ctx context.Context, arg UpdateEmployeeByUserIdParams) (*Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployeeByUserId,
		arg.UserID,
		arg.JobTitle,
		arg.Country,
		arg.Salary,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobTitle,
		&i.Country,
		&i.Salary,
		&i.CreatedAt,
	)
	return &i, err
}
